{"ast":null,"code":"var _jsxFileName = \"/Users/sanilmanaktala/Desktop/New App/leave-tracking-frontend/src/contexts/NotificationContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { useAuth } from './AuthContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst NotificationContext = /*#__PURE__*/createContext();\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\nexport const useNotifications = () => {\n  _s();\n  const context = useContext(NotificationContext);\n  if (!context) {\n    throw new Error('useNotifications must be used within a NotificationProvider');\n  }\n  return context;\n};\n_s(useNotifications, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const NotificationProvider = ({\n  children\n}) => {\n  _s2();\n  const [notifications, setNotifications] = useState([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const {\n    token,\n    user\n  } = useAuth();\n\n  // Fetch notifications\n  const fetchNotifications = async (page = 1, limit = 20, unreadOnly = false) => {\n    if (!token) return;\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await fetch(`${API_BASE_URL}/api/notifications?page=${page}&limit=${limit}&unreadOnly=${unreadOnly}`, {\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n      if (response.ok) {\n        const data = await response.json();\n        setNotifications(data.notifications);\n        setUnreadCount(data.unreadCount);\n        return data;\n      } else {\n        throw new Error('Failed to fetch notifications');\n      }\n    } catch (err) {\n      console.error('Fetch notifications error:', err);\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Mark notification as read\n  const markAsRead = async notificationId => {\n    if (!token) return;\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/notifications/${notificationId}/read`, {\n        method: 'PUT',\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n      if (response.ok) {\n        // Update local state\n        setNotifications(prev => prev.map(notif => notif._id === notificationId ? {\n          ...notif,\n          isRead: true,\n          readAt: new Date()\n        } : notif));\n        setUnreadCount(prev => Math.max(0, prev - 1));\n      }\n    } catch (err) {\n      console.error('Mark notification as read error:', err);\n    }\n  };\n\n  // Mark all notifications as read\n  const markAllAsRead = async () => {\n    if (!token) return;\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/notifications/read-all`, {\n        method: 'PUT',\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n      if (response.ok) {\n        // Update local state\n        setNotifications(prev => prev.map(notif => ({\n          ...notif,\n          isRead: true,\n          readAt: new Date()\n        })));\n        setUnreadCount(0);\n      }\n    } catch (err) {\n      console.error('Mark all notifications as read error:', err);\n    }\n  };\n\n  // Add new notification to local state (for real-time updates)\n  const addNotification = notification => {\n    setNotifications(prev => [notification, ...prev]);\n    if (!notification.isRead) {\n      setUnreadCount(prev => prev + 1);\n    }\n  };\n\n  // Get notification icon based on type\n  const getNotificationIcon = type => {\n    switch (type) {\n      case 'leave_submitted':\n        return 'ðŸ“';\n      case 'leave_approved':\n        return 'âœ…';\n      case 'leave_rejected':\n        return 'âŒ';\n      case 'leave_cancelled':\n        return 'ðŸš«';\n      case 'role_changed':\n        return 'ðŸ‘¤';\n      case 'team_member_added':\n        return 'ðŸ‘¥';\n      case 'team_member_removed':\n        return 'ðŸ‘¥';\n      case 'system_announcement':\n        return 'ðŸ“¢';\n      default:\n        return 'ðŸ””';\n    }\n  };\n\n  // Get notification color based on type\n  const getNotificationColor = type => {\n    switch (type) {\n      case 'leave_approved':\n        return 'text-green-600';\n      case 'leave_rejected':\n        return 'text-red-600';\n      case 'role_changed':\n        return 'text-blue-600';\n      case 'system_announcement':\n        return 'text-purple-600';\n      default:\n        return 'text-gray-600';\n    }\n  };\n\n  // Auto-fetch notifications when user logs in\n  useEffect(() => {\n    if (user && token) {\n      fetchNotifications();\n    } else {\n      setNotifications([]);\n      setUnreadCount(0);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [user, token]);\n\n  // Poll for new notifications every 30 seconds when user is active\n  useEffect(() => {\n    if (!user || !token) return;\n    let interval;\n    let isPageVisible = !document.hidden;\n    const startPolling = () => {\n      interval = setInterval(() => {\n        // Only fetch if page is visible and user is active\n        if (isPageVisible && !document.hidden) {\n          fetchNotifications(1, 20, false);\n        }\n      }, 30000); // Poll every 30 seconds\n    };\n    const stopPolling = () => {\n      if (interval) {\n        clearInterval(interval);\n        interval = null;\n      }\n    };\n\n    // Handle page visibility changes\n    const handleVisibilityChange = () => {\n      isPageVisible = !document.hidden;\n      if (isPageVisible) {\n        // Fetch immediately when page becomes visible, then start polling\n        fetchNotifications(1, 20, false);\n        startPolling();\n      } else {\n        stopPolling();\n      }\n    };\n\n    // Listen for page visibility changes\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    // Start polling initially\n    startPolling();\n    return () => {\n      stopPolling();\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [user, token]);\n  const value = {\n    notifications,\n    unreadCount,\n    loading,\n    error,\n    fetchNotifications,\n    markAsRead,\n    markAllAsRead,\n    addNotification,\n    getNotificationIcon,\n    getNotificationColor\n  };\n  return /*#__PURE__*/_jsxDEV(NotificationContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 242,\n    columnNumber: 5\n  }, this);\n};\n_s2(NotificationProvider, \"XJLMZgZ9p1saBxlhI5mfACD4eb4=\", false, function () {\n  return [useAuth];\n});\n_c = NotificationProvider;\nexport default NotificationContext;\nvar _c;\n$RefreshReg$(_c, \"NotificationProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useAuth","jsxDEV","_jsxDEV","NotificationContext","API_BASE_URL","process","env","REACT_APP_API_URL","useNotifications","_s","context","Error","NotificationProvider","children","_s2","notifications","setNotifications","unreadCount","setUnreadCount","loading","setLoading","error","setError","token","user","fetchNotifications","page","limit","unreadOnly","response","fetch","headers","ok","data","json","err","console","message","markAsRead","notificationId","method","prev","map","notif","_id","isRead","readAt","Date","Math","max","markAllAsRead","addNotification","notification","getNotificationIcon","type","getNotificationColor","interval","isPageVisible","document","hidden","startPolling","setInterval","stopPolling","clearInterval","handleVisibilityChange","addEventListener","removeEventListener","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/sanilmanaktala/Desktop/New App/leave-tracking-frontend/src/contexts/NotificationContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport { useAuth } from './AuthContext';\n\nconst NotificationContext = createContext();\n\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\n\nexport const useNotifications = () => {\n  const context = useContext(NotificationContext);\n  if (!context) {\n    throw new Error('useNotifications must be used within a NotificationProvider');\n  }\n  return context;\n};\n\nexport const NotificationProvider = ({ children }) => {\n  const [notifications, setNotifications] = useState([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const { token, user } = useAuth();\n\n  // Fetch notifications\n  const fetchNotifications = async (page = 1, limit = 20, unreadOnly = false) => {\n    if (!token) return;\n\n    try {\n      setLoading(true);\n      setError(null);\n\n      const response = await fetch(\n        `${API_BASE_URL}/api/notifications?page=${page}&limit=${limit}&unreadOnly=${unreadOnly}`,\n        {\n          headers: {\n            'Authorization': `Bearer ${token}`,\n            'Content-Type': 'application/json'\n          }\n        }\n      );\n\n      if (response.ok) {\n        const data = await response.json();\n        setNotifications(data.notifications);\n        setUnreadCount(data.unreadCount);\n        return data;\n      } else {\n        throw new Error('Failed to fetch notifications');\n      }\n    } catch (err) {\n      console.error('Fetch notifications error:', err);\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Mark notification as read\n  const markAsRead = async (notificationId) => {\n    if (!token) return;\n\n    try {\n      const response = await fetch(\n        `${API_BASE_URL}/api/notifications/${notificationId}/read`,\n        {\n          method: 'PUT',\n          headers: {\n            'Authorization': `Bearer ${token}`,\n            'Content-Type': 'application/json'\n          }\n        }\n      );\n\n      if (response.ok) {\n        // Update local state\n        setNotifications(prev => \n          prev.map(notif => \n            notif._id === notificationId \n              ? { ...notif, isRead: true, readAt: new Date() }\n              : notif\n          )\n        );\n        setUnreadCount(prev => Math.max(0, prev - 1));\n      }\n    } catch (err) {\n      console.error('Mark notification as read error:', err);\n    }\n  };\n\n  // Mark all notifications as read\n  const markAllAsRead = async () => {\n    if (!token) return;\n\n    try {\n      const response = await fetch(\n        `${API_BASE_URL}/api/notifications/read-all`,\n        {\n          method: 'PUT',\n          headers: {\n            'Authorization': `Bearer ${token}`,\n            'Content-Type': 'application/json'\n          }\n        }\n      );\n\n      if (response.ok) {\n        // Update local state\n        setNotifications(prev => \n          prev.map(notif => ({ \n            ...notif, \n            isRead: true, \n            readAt: new Date() \n          }))\n        );\n        setUnreadCount(0);\n      }\n    } catch (err) {\n      console.error('Mark all notifications as read error:', err);\n    }\n  };\n\n  // Add new notification to local state (for real-time updates)\n  const addNotification = (notification) => {\n    setNotifications(prev => [notification, ...prev]);\n    if (!notification.isRead) {\n      setUnreadCount(prev => prev + 1);\n    }\n  };\n\n  // Get notification icon based on type\n  const getNotificationIcon = (type) => {\n    switch (type) {\n      case 'leave_submitted':\n        return 'ðŸ“';\n      case 'leave_approved':\n        return 'âœ…';\n      case 'leave_rejected':\n        return 'âŒ';\n      case 'leave_cancelled':\n        return 'ðŸš«';\n      case 'role_changed':\n        return 'ðŸ‘¤';\n      case 'team_member_added':\n        return 'ðŸ‘¥';\n      case 'team_member_removed':\n        return 'ðŸ‘¥';\n      case 'system_announcement':\n        return 'ðŸ“¢';\n      default:\n        return 'ðŸ””';\n    }\n  };\n\n  // Get notification color based on type\n  const getNotificationColor = (type) => {\n    switch (type) {\n      case 'leave_approved':\n        return 'text-green-600';\n      case 'leave_rejected':\n        return 'text-red-600';\n      case 'role_changed':\n        return 'text-blue-600';\n      case 'system_announcement':\n        return 'text-purple-600';\n      default:\n        return 'text-gray-600';\n    }\n  };\n\n  // Auto-fetch notifications when user logs in\n  useEffect(() => {\n    if (user && token) {\n      fetchNotifications();\n    } else {\n      setNotifications([]);\n      setUnreadCount(0);\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [user, token]);\n\n  // Poll for new notifications every 30 seconds when user is active\n  useEffect(() => {\n    if (!user || !token) return;\n\n    let interval;\n    let isPageVisible = !document.hidden;\n\n    const startPolling = () => {\n      interval = setInterval(() => {\n        // Only fetch if page is visible and user is active\n        if (isPageVisible && !document.hidden) {\n          fetchNotifications(1, 20, false);\n        }\n      }, 30000); // Poll every 30 seconds\n    };\n\n    const stopPolling = () => {\n      if (interval) {\n        clearInterval(interval);\n        interval = null;\n      }\n    };\n\n    // Handle page visibility changes\n    const handleVisibilityChange = () => {\n      isPageVisible = !document.hidden;\n      if (isPageVisible) {\n        // Fetch immediately when page becomes visible, then start polling\n        fetchNotifications(1, 20, false);\n        startPolling();\n      } else {\n        stopPolling();\n      }\n    };\n\n    // Listen for page visibility changes\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    // Start polling initially\n    startPolling();\n\n    return () => {\n      stopPolling();\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [user, token]);\n\n  const value = {\n    notifications,\n    unreadCount,\n    loading,\n    error,\n    fetchNotifications,\n    markAsRead,\n    markAllAsRead,\n    addNotification,\n    getNotificationIcon,\n    getNotificationColor\n  };\n\n  return (\n    <NotificationContext.Provider value={value}>\n      {children}\n    </NotificationContext.Provider>\n  );\n};\n\nexport default NotificationContext;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}